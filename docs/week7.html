<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Nils W Metternich, Luis Schenoni, and Sigrid Weber" />


<title>Week 7: International involvement in domestic conflict</title>

<script src="site_libs/header-attrs-2.23/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Spread of Conflict</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="introduction.html">Week 1 Part 1</a>
</li>
<li>
  <a href="week1.html">Week 1 Part 2</a>
</li>
<li>
  <a href="week2.html">Week 2</a>
</li>
<li>
  <a href="week3.html">Week 3</a>
</li>
<li>
  <a href="week4.html">Week 4</a>
</li>
<li>
  <a href="week7.html">Week 7</a>
</li>
<li>
  <a href="week8.html">Week 8</a>
</li>
<li>
  <a href="week9.html">Week 9</a>
</li>
<li>
  <a href="week10.html">Week 10</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Week 7: International involvement in
domestic conflict</h1>
<h4 class="author">Nils W Metternich, Luis Schenoni, and Sigrid
Weber</h4>

</div>


<p>Today, we are applying network analysis to the question of the topic
of external support by other states for rebels and governments that
fight each other in domestic conflict. During domestic conflict or
intra-state conflict, we usually have one or more rebel groups fighting
the government. Foreign governments can either decide to support the
rebels or they can decide to support the government.</p>
<p>We will be using the UCDP dataset to look at these networks of
support. On the one hand, we want to understand in which states we saw
rebels fighting that were supported by external states. On the other
hand, we want to understand where governments at war with rebels
received support by other external states.</p>
<div id="load-required-libraries" class="section level2">
<h2>Load required libraries</h2>
<p>As usual, donâ€™t forget to call the libraries that you need for your
code to run. I am adding a few more packages that you might not have
used before. Remember to install them once (if you never used them) and
then load them.</p>
<pre class="r"><code>library(statnet)
library(tidyverse)
library(countrycode)

#install.packages(&quot;haven&quot;)
# this package teaches R how to read stata files (dta)
library(haven)

#install.packages(&quot;haven&quot;) 
# this package teaches R how to read xls and xlsx sheets
library(readxl)</code></pre>
<!-- ## External support for rebels: NAG data from Belgin San Akca -->
<!-- The [State-NAG Cooperation Dataset](http://home.ku.edu.tr/~bakca/#complementary) has information on 454 rebel groups, which emerged in the post-WWII period, and how they were supported by other governments. It includes descriptive information about ideational features and objectives of nonstate armed groups, their state supporters, type and duration of support, and all sources used for coding date. Sources and descriptive characteristics of NAGs are available on [project website](https://www.armedgroups.net/).  -->
<!-- We will be focusing on the key variables `tarnum` (the country code of the state targeted by the non-state actor), `psnum` (the country code of the state supporting the non-state actor) and the year of support. We will *not* focus on which rebel group is fighting which state but you could think of analyses on the rebel rather than state level for your assignments. -->
<!-- The code below turns the whole NAG data into a network. This network links states supporting rebels (senders) to states being attacked by those rebels (receivers). The links between senders and receivers are external state support for the rebels in the receiving country.  -->
<!-- ```{r networks-rebels} -->
<!-- # read the data -->
<!-- nag <- read_dta("data_week7_new/BookFinalData.dta") -->
<!-- # recode the country codes into abbreviated state names -->
<!-- nag$target <- countrycode(nag$tarnum,origin="cown",destination = "cowc")  -->
<!-- nag$supporter <- countrycode(nag$psnum,origin="cown",destination = "cowc")  -->
<!-- # clean up Germany that is often not identified (because of East and West Germany) -->
<!-- nag$supporter <- ifelse(nag$psnum==260, "GER", nag$supporter)  -->
<!-- # selecting relevant variables -->
<!-- nag <-  select(nag, c("target","supporter","year")) -->
<!-- # now the data is in a good shape to calculate network statistics -->
<!-- # get string of unique states in the data -->
<!-- nag_states <- unique(c(as.character(nag$target), -->
<!--                        as.character(nag$supporter))) -->
<!-- # make an empty matrix -->
<!-- nagMat <- matrix(0,nrow=length(nag_states),ncol=length(nag_states))  -->
<!-- rownames(nagMat) <-    nag_states -->
<!-- colnames(nagMat) <-    nag_states -->
<!-- # fill the empty matrix -->
<!-- for(i in 1:dim(nag)[1]){ -->
<!--    nagMat[as.character(nag$supporter[i]),as.character(nag$target[i])] <- -->
<!--      nagMat[as.character(nag$supporter[i]),as.character(nag$target[i])]+1 -->
<!-- } -->
<!-- # tell R to understand this matrix as a network -->
<!-- nagNet <- network(nagMat, -->
<!--                   directed=TRUE) -->
<!-- network.vertex.names(nagNet) <- nag_states -->
<!-- ``` -->
<!-- Based on this network of external rebel support, we can try to identify the countries that send support to a lot of different rebels in different states (*outdegree centrality*) but also which states are heavily targeted through external rebel support by various other states (*indegree centrality*). Also revise the other centrality measures!  -->
<!-- ```{r rebels-centrality , class.source = 'fold-hide'} -->
<!-- # which states target other states the most by supporting rebels (outdegree centrality) -->
<!-- out.n <- degree(nagNet,cmode="outdegree") -->
<!-- # which starts are the most targeted through other states' support of rebels (indegree centrality) -->
<!-- in.n <- degree(nagNet,cmode="indegree") -->
<!-- centrality <- data.frame(state=nag_states, -->
<!--                          indegree = in.n, -->
<!--                          outdegree = out.n) -->
<!-- ``` -->
<!-- **Countries with the highest outdegree centrality:** -->
<!-- ```{r rebels-outentrality , class.source = 'fold-hide'} -->
<!-- # Outdegree: USA, UK, FR, Rus, China -->
<!-- centrality |> arrange(-outdegree) |> head() -->
<!-- ``` -->
<!-- **Countries with the highest indegree centrality:** -->
<!-- ```{r rebels-incentrality , class.source = 'fold-hide'} -->
<!-- # Indegree: USA, China, UK, Russia, France -->
<!-- centrality |> arrange(-indegree) |> head() -->
<!-- ``` -->
<!-- To make the network a little bit less overwhelming for visual inspection, I only plot ties if a state supported at least 20 rebel groups across all years counting separately. You can do this by manipulating the `thres` argument in the `gplot`function. I also display countries with a high indegree centrality as bigger.  -->
<!-- ```{r rebels-visual, class.source = 'fold-hide'} -->
<!-- gplot(nagNet, -->
<!--       label=nag_states,  -->
<!--       vertex.cex=log(in.n), -->
<!--       edge.lwd=0.0001, -->
<!--       thres>20, -->
<!--       vertex.col ="slateblue", vertex.border = "slateblue", -->
<!--       edge.col="gray",gmode="digraph") -->
<!-- ``` -->
</div>
<div
id="external-support-for-governments-ucdp-external-support-dataset."
class="section level2">
<h2>External support for governments: UCDP External Support
dataset.</h2>
<p>The <a
href="https://ucdp.uu.se/downloads/index.html#externalsupport">UCDP
External Support dataset</a> provides information on the existence,
type, and provider of external support for all warring parties
(non-state and governments) coded as active in UCDP data, on an annual
basis, between 1975 and 2017. The triadic version of the datata
constains the warring-party-supporter-opponent-year (or triad-year) as
units of analysis.</p>
<p>While we could use this data to analyse both support for rebels or
governments, we will focus in this second network only on states
supporting other governments that currently fight a rebel group in a
domestic conflict. Again we will read the data, clean it and bring it in
network shape. We remove observations of support for non-state actors
with the help of <code>ext_nonstate</code> (whether the sender state is
a state) and <code>actor_nonstate</code> (whether the receiving actor is
a state).</p>
<p>The relevant variables we will focus on are <code>ext_name</code>
(the name of the actor providing support to the government),
<code>actor_name</code> (the name of the warring party receiving
support) and the year of support given.</p>
<pre class="r"><code>ucdp &lt;- read_xlsx(&quot;~/Desktop/temp/ucdp-esd-ty-181.xlsx&quot;)

# sender of foreign support must be a state!
ucdp &lt;- filter(ucdp, ext_nonstate == 0)

# recipient of foreign support must be a government!
ucdp &lt;- filter(ucdp, actor_nonstate == 0)

# select relevant columns
ucdp &lt;- select(ucdp, c(&quot;ext_name&quot;,&quot;actor_name&quot;,&quot;year&quot;))

# give them more intuitive names
names(ucdp) &lt;- c(&quot;supporter&quot;,&quot;recipient&quot;,&quot;year&quot;)

# fix double-entries
ucdp &lt;- separate_rows(ucdp,&quot;recipient&quot;,sep = &quot;,&quot;)

# turn country codes into names
ucdp$recipient &lt;- countrycode(ucdp$recipient,origin=&quot;country.name&quot;,
                              destination = &quot;cowc&quot;) 
ucdp$supporter &lt;- countrycode(ucdp$supporter,origin=&quot;country.name&quot;,
                              destination = &quot;cowc&quot;) 

# remove entry that seem wrong
ucdp &lt;- filter(ucdp, supporter != &quot;Emirati elements&quot;)

# get string of unique states in the data
ucdp_states &lt;- unique(c(as.character(ucdp$supporter),
                       as.character(ucdp$recipient)))

# make an empty matrix
ucdpMat &lt;- matrix(0,nrow=length(ucdp_states),ncol=length(ucdp_states)) 
rownames(ucdpMat) &lt;-    ucdp_states
colnames(ucdpMat) &lt;-    ucdp_states

# fill the empty matrix
for(i in 1:dim(ucdp)[1]){
    ucdpMat[as.character(ucdp$supporter[i]),as.character(ucdp$recipient[i])] &lt;-
      ucdpMat[as.character(ucdp$supporter[i]),as.character(ucdp$recipient[i])]+1
}

# tell R to understand this matrix as a network
ucdpNet &lt;- network(ucdpMat,
                  directed=TRUE)
network.vertex.names(ucdpNet) &lt;- ucdp_states</code></pre>
<p>Based on this network of external government support, we can try to
identify the countries that send support to a lot of different
governments in different states (<em>outdegree centrality</em>) but also
which states are heavy receivers of external support by various other
states (<em>indegree centrality</em>).</p>
<pre class="r fold-hide"><code># which states target other states the most by supporting rebels (outdegree centrality)
out.n &lt;- degree(ucdpNet,cmode=&quot;outdegree&quot;)

# which starts are the most targeted through other states&#39; support of rebels (indegree centrality)
in.n &lt;- degree(ucdpNet,cmode=&quot;indegree&quot;)

centrality &lt;- data.frame(state=ucdp_states,
                         indegree = in.n,
                         outdegree = out.n)</code></pre>
<p><strong>Countries with the highest outdegree centrality:</strong></p>
<pre class="r fold-hide"><code># Outdegree: USA, France, Russia, UK
centrality |&gt; arrange(-outdegree) |&gt; head()</code></pre>
<pre><code>##   state indegree outdegree
## 1   USA       72        56
## 2   FRN        0        29
## 3   RUS        1        28
## 4   UKG       60        22
## 5   CHN        0        16
## 6   GMY        0        14</code></pre>
<p><strong>Countries with the highest indegree centrality:</strong></p>
<pre class="r fold-hide"><code># Indegree: Mali, USA, Afghanistan, UK, Iraq
centrality |&gt; arrange(-indegree) |&gt; head()</code></pre>
<pre><code>##   state indegree outdegree
## 1   MLI       75         5
## 2   USA       72        56
## 3   AFG       69         4
## 4   UKG       60        22
## 5   IRQ       58         5
## 6   AUL       45        10</code></pre>
<p>To visualise the network, I plot the size of the nodes bigger for
higher levels of indegree centrality.</p>
<pre class="r fold-hide"><code>gplot(ucdpNet,
      label=ucdp_states, 
      vertex.cex=log(in.n),
      edge.lwd=0.001,
      vertex.col =&quot;goldenrod3&quot;,vertex.border = &quot;goldenrod3&quot;,
      edge.col=&quot;gray&quot;,
      gmode=&quot;digraph&quot;)</code></pre>
<p><img src="week7_files/figure-html/ucdp-visual-1.png" width="672" /></p>
<!-- # ## Example of Syria -->
<!-- #  -->
<!-- # In the seminar, we worked together on plotting the network of support to NAGs from external states in Syria. We also worked on plotting a network of support for the government of Syria. You can access the results and the coding below. -->
<!-- #  -->
<!-- # **Which states support NAGs in Syria?** -->
<!-- #  -->
<!-- # The network below plots the states that ever supported directly some opposition group in Syria.  -->
<!-- # ```{r  syria-opp, class.source = 'fold-hide'} -->
<!-- #  -->
<!-- # # who supports some NAG in Syria -->
<!-- # syriaopp <- filter(nag, target == "SYR") |> pull(supporter) -->
<!-- # syriaopp <- unique(c(syriaopp, "SYR")) -->
<!-- #  -->
<!-- # # subset the data to Syria plus all countries that support NAGs in Syria -->
<!-- # syria_opposition <- filter(nag, target == "SYR" & supporter %in% syriaopp) -->
<!-- #  -->
<!-- # syria_opp_states <- unique(c(syria_opposition$target,syria_opposition$supporter)) -->
<!-- #  -->
<!-- # # make an empty matrix and fill it -->
<!-- # syriaoppMat <- matrix(0,nrow=length(syria_opp_states), -->
<!-- #                       ncol=length(syria_opp_states))  -->
<!-- # rownames(syriaoppMat) <-     syria_opp_states -->
<!-- # colnames(syriaoppMat) <-     syria_opp_states -->
<!-- #  -->
<!-- # for(i in 1:dim(syria_opposition)[1]){ -->
<!-- #  syriaoppMat[as.character(syria_opposition$supporter[i]), -->
<!-- #              as.character(syria_opposition$target[i])] <- -->
<!-- #    syriaoppMat[as.character(syria_opposition$supporter[i]), -->
<!-- #                as.character(syria_opposition$target[i])]+1 -->
<!-- # } -->
<!-- #  -->
<!-- # syriaoppNet <- network(syriaoppMat,directed=TRUE) -->
<!-- # network.vertex.names(syriaoppNet) <- syria_opp_states -->
<!-- #  -->
<!-- # gplot(syriaoppNet, -->
<!-- #       label= syria_opp_states, -->
<!-- #       edge.lwd=0.001, -->
<!-- #       vertex.col ="slateblue",vertex.border = "slateblue", -->
<!-- #       edge.col="gray", -->
<!-- #       gmode="digraph") -->
<!-- # ``` -->
<!-- #  -->
<!-- # **Do states that support NAGs in Syria also support opposition movements in other states that support the Syrian opposition?** -->
<!-- #  -->
<!-- # In the network below, we added complexity by checking if states that support the opposition in Syria also support the opposition in other states that support the Syrian opposition. As an example, if the US supports some opposition in Syria and Lebanon does the same, we would expect that the US and the Lebanese government are on the same page. However, it could also be that the US is inconsistent and supports the opposition in Lebanon *despite* the fact that they both support the opposition in Syria. From the plot, we can see that this actually seems to be quite common.  -->
<!-- #  -->
<!-- # ```{r  syria-opp2, class.source = 'fold-hide'} -->
<!-- #  -->
<!-- # # subset the data to Syria plus all countries that support NAGs in Syria -->
<!-- # syria_opposition2 <- filter(nag, target %in% syriaopp & supporter %in% syriaopp) -->
<!-- #  -->
<!-- # syria_opp_states2 <- unique(c(syria_opposition2$target,syria_opposition2$supporter)) -->
<!-- #  -->
<!-- # # make an empty matrix and fill it -->
<!-- # syriaoppMat2 <- matrix(0,nrow=length(syria_opp_states2), -->
<!-- #                       ncol=length(syria_opp_states2))  -->
<!-- # rownames(syriaoppMat2) <-    syria_opp_states2 -->
<!-- # colnames(syriaoppMat2) <-    syria_opp_states2 -->
<!-- #  -->
<!-- # for(i in 1:dim(syria_opposition2)[1]){ -->
<!-- #  syriaoppMat2[as.character(syria_opposition2$supporter[i]), -->
<!-- #              as.character(syria_opposition2$target[i])] <- -->
<!-- #    syriaoppMat2[as.character(syria_opposition2$supporter[i]), -->
<!-- #                as.character(syria_opposition2$target[i])]+1 -->
<!-- # } -->
<!-- #  -->
<!-- # # better weighting -->
<!-- # syriaoppMat2 <- syriaoppMat2/22 -->
<!-- # syriaoppNet2 <- network(syriaoppMat2,directed=TRUE,ignore.eval=FALSE, -->
<!-- #                   names.eval='weight') -->
<!-- # network.vertex.names(syriaoppNet2) <- syria_opp_states2 -->
<!-- #  -->
<!-- # plot(syriaoppNet2, displaylabels=TRUE,  -->
<!-- #      vertex.col = "slateblue",vertex.border = "slateblue", -->
<!-- #      edge.col ="gray", -->
<!-- #      label.cex=.75,label.col="black",edge.lwd="weight", vertex.cex=2)  -->
<!-- #  -->
<!-- # ``` -->
<!-- #  -->
<!-- #  -->
<!-- # **Which states support the government in Syria?** -->
<!-- #  -->
<!-- # The network below plots the states that ever supported directly the government in Syria.  -->
<!-- #  -->
<!-- # ```{r syria-gov, class.source = 'fold-hide'} -->
<!-- #  -->
<!-- # # who supports the government in Syria -->
<!-- # syriagov <- filter(ucdp, recipient == "SYR") |> pull(supporter) -->
<!-- # syriagov <- unique(c(syriagov, "SYR")) -->
<!-- #  -->
<!-- # # subset the data to Syria plus all countries that the  Syrian gov -->
<!-- # syria_government <- filter(ucdp, recipient == "SYR" & supporter %in% syriagov) -->
<!-- #  -->
<!-- # syria_gov_states <- unique(c(syria_government$recipient, -->
<!-- #                              syria_government$supporter)) -->
<!-- #  -->
<!-- # # make an empty matrix -->
<!-- # syriagovMat <- matrix(0,nrow=length(syria_gov_states), -->
<!-- #                       ncol=length(syria_gov_states))  -->
<!-- # rownames(syriagovMat) <-     syria_gov_states -->
<!-- # colnames(syriagovMat) <-     syria_gov_states -->
<!-- #  -->
<!-- # # fill the empty matrix -->
<!-- # for(i in 1:dim(syria_government)[1]){ -->
<!-- #  syriagovMat[as.character(syria_government$supporter[i]), -->
<!-- #          as.character(syria_government$recipient[i])] <- -->
<!-- #    syriagovMat[as.character(syria_government$supporter[i]), -->
<!-- #            as.character(syria_government$recipient[i])]+1 -->
<!-- # } -->
<!-- #  -->
<!-- # # tell R to understand this matrix as a network -->
<!-- # syriagovNet <- network(syriagovMat, -->
<!-- #                   directed=TRUE) -->
<!-- # network.vertex.names(syriagovNet) <- syria_gov_states  -->
<!-- #  -->
<!-- # gplot(syriagovNet, -->
<!-- #       label= syria_gov_states, -->
<!-- #       edge.lwd=0.001, -->
<!-- #       vertex.col ="goldenrod3",vertex.border = "goldenrod3", -->
<!-- #       edge.col="gray", -->
<!-- #       gmode="digraph") -->
<!-- # ``` -->
<!-- #  -->
<!-- #  -->
<!-- # **Which other states do states support that support the Syrian government?** -->
<!-- #  -->
<!-- # In the plot below, we map the core states that support the Syrian government (Iraq, Russia, Iran) and we map out all other states that those three actors are supporting.  -->
<!-- #  -->
<!-- # ```{r syria-gov2, class.source = 'fold-hide'} -->
<!-- #  -->
<!-- # # subset the data to Syria plus all countries that the  Syrian gov -->
<!-- # syria_government2 <- filter(ucdp, supporter %in% syriagov) -->
<!-- #  -->
<!-- # syria_gov_states2 <- unique(c(syria_government2$recipient, -->
<!-- #                              syria_government2$supporter)) -->
<!-- #  -->
<!-- # # make an empty matrix -->
<!-- # syriagovMat2 <- matrix(0,nrow=length(syria_gov_states2), -->
<!-- #                       ncol=length(syria_gov_states2))  -->
<!-- # rownames(syriagovMat2) <-    syria_gov_states2 -->
<!-- # colnames(syriagovMat2) <-    syria_gov_states2 -->
<!-- #  -->
<!-- #  -->
<!-- # # fill the empty matrix -->
<!-- # for(i in 1:dim(syria_government2)[1]){ -->
<!-- #  syriagovMat2[as.character(syria_government2$supporter[i]), -->
<!-- #          as.character(syria_government2$recipient[i])] <- -->
<!-- #    syriagovMat2[as.character(syria_government2$supporter[i]), -->
<!-- #            as.character(syria_government2$recipient[i])]+1 -->
<!-- # } -->
<!-- #  -->
<!-- # # for better weighting -->
<!-- # syriagovMat2 <- syriagovMat2/5 -->
<!-- # syriagovNet2 <- network(syriagovMat2,directed=TRUE,ignore.eval=FALSE, -->
<!-- #                   names.eval='weight') -->
<!-- # network.vertex.names(syriagovNet2) <- syria_gov_states2 -->
<!-- #  -->
<!-- # plot(syriagovNet2, displaylabels=TRUE,  -->
<!-- #       vertex.col ="goldenrod3",vertex.border = "goldenrod3", -->
<!-- #      edge.col ="gray", -->
<!-- #      label.cex=.75,label.col="black",edge.lwd="weight", vertex.cex=2)  -->
<!-- ``` -->
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
